#version 430 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(std430, binding = 0) buffer input_layout
{
    float Densities[];
	layout(offset = 20000) float NearDensities[];
    layout(offset = 40000) uint SpatialOffsets[];  // Explicit offset
    layout(offset = 60000) uvec4 SpatialIndices[];
    layout(offset = 140000) vec2 PredictedPositions[];
	layout(offset = 180000) vec2 Velocities[];
};
layout(std430, binding = 1) buffer output_layout
{
	vec2 OutVelocities[];
};

uniform float deltaTime;
uniform float nearPressureMultiplier;
uniform float pressureMultiplier;
uniform float targetDensity;
uniform float smoothingRadius;
uniform uint numParticles;
uniform float SpikyPow3DerivativeScalingFactor;
uniform float SpikyPow2DerivativeScalingFactor;

const vec2 offsets2D[9] =
{
	vec2(-1, 1),
	vec2(0, 1),
	vec2(1, 1),
	vec2(-1, 0),
	vec2(0, 0),
	vec2(1, 0),
	vec2(-1, -1),
	vec2(0, -1),
	vec2(1, -1),
};

// Constants used for hashing
const uint hashK1 = 15823;
const uint hashK2 = 9737333;

// Convert floating point position into an integer cell coordinate
vec2 GetCell2D(vec2 position, float radius)
{
	return floor(position / radius);
}

// Hash cell coordinate to a single unsigned integer
uint HashCell2D(vec2 cell)
{
	uint a = uint(cell.x) * hashK1;
	uint b = uint(cell.y) * hashK2;
	return (a + b);
}

uint KeyFromHash(uint hash, uint tableSize)
{
	return hash % tableSize;
}

float NearDensityDerivative(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * v * SpikyPow3DerivativeScalingFactor;
	}
	return 0;
}

float DensityDerivative(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * SpikyPow2DerivativeScalingFactor;
	}
	return 0;
}

float PressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
	return nearPressureMultiplier * nearDensity;
}


vec2 CalculatePressure()
{
	if (gl_GlobalInvocationID.x >= numParticles) return vec2(0,0);

	float density = Densities[gl_GlobalInvocationID.x];
	float densityNear = NearDensities[gl_GlobalInvocationID.x];
	float pressure = PressureFromDensity(density);
	float nearPressure = NearPressureFromDensity(densityNear);
	vec2 pressureForce = vec2(0,0);
	
	vec2 pos = PredictedPositions[gl_GlobalInvocationID.x];
	vec2 originCell = GetCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 9; i ++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uvec3 indexData = SpatialIndices[currIndex].xyz;
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData.z != key) break;
			// Skip if hash does not match
			if (indexData.y != hash) continue;

			uint neighbourIndex = indexData.x;
			// Skip if looking at self
			if (neighbourIndex == gl_GlobalInvocationID.x) continue;

			vec2 neighbourPos = PredictedPositions[neighbourIndex];
			vec2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate pressure force
			float dst = sqrt(sqrDstToNeighbour);
			vec2 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : vec2(0, 1);

			float neighbourDensity = Densities[neighbourIndex];
			float neighbourNearDensity = NearDensities[neighbourIndex];
			float neighbourPressure = PressureFromDensity(neighbourDensity);
			float neighbourNearPressure = NearPressureFromDensity(neighbourNearDensity);

			float sharedPressure = (pressure + neighbourPressure) * 0.5;
			float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;

			pressureForce += dirToNeighbour * DensityDerivative(dst, smoothingRadius) * sharedPressure / neighbourDensity;
			pressureForce += dirToNeighbour * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / neighbourNearDensity;
		}
	}

	return pressureForce;
}

void main() {	
	vec2 pressure = CalculatePressure();
	//OutDensities[gl_GlobalInvocationID.x] = uint(SpatialOffsets[gl_GlobalInvocationID.x]);
	OutVelocities[gl_GlobalInvocationID.x] = Velocities[gl_GlobalInvocationID.x] + (pressure / Densities[gl_GlobalInvocationID.x] * deltaTime);
	//OutNearDensities[gl_GlobalInvocationID.x] = density.y;
}